[@concept-design-overview](../../background/concept-design-overview.md)

[@concept-specifications](../../background/concept-specifications.md)

[@implementing-concepts](../../background/implementing-concepts.md)

# concept: SuggestChord
*   **concept**: SuggestChord
*   **purpose**: offer users suggestions for suitable chords to place in any position of a progression.
*   **principle**: when a user selects a slot in a sequence, the system analyzes the context—the units before and after that slot— and generates a list of candidate units that would fit well in that position. If the sequence is empty, the system provides starting units. If the slot is at the end, the system suggests conappltinuations.

*   **actions**:
    *   `suggestProgression(length: Number, key: String): (String[])`
        *   **requires** `length >= 0`, `key` is a key in standard music notation
        *   **effect** returns a chord progression of length `length` in key `key`, generated by an LLM.
    *   `suggestChord(chords: (String | null)[], position: Number): (String[])`
        *   **requires**: every `chord` is a valid chord in standard music notation or `null` if there is no chord at that index, `position` is a valid index in the `chords` array
        *   **effect**: returns a list of suggested chords in standard music notation to put in `position`, generated by an LLM given the context of the chords before and after it and the key.

# implement: SuggestChord
# response:

```typescript
// file: src/SuggestChord/SuggestChordConcept.ts

import { Collection, Db } from "npm:mongodb";
import { Empty } from "@utils/types.ts";

/**
 * @concept SuggestChord
 * @purpose offer users suggestions for suitable chords to place in any position of a progression.
 *
 * @principle when a user selects a slot in a sequence, the system analyzes the context—the units before and after that slot—
 * and generates a list of candidate units that would fit well in that position. If the sequence is empty,
 * the system provides starting units. If the slot is at the end, the system suggests continuations.
 */
export default class SuggestChordConcept {
  // This concept is designed to be largely stateless regarding the musical data itself,
  // as keys and chord progressions are passed as arguments to its actions rather
  // than being stored persistently by the concept.
  // The 'db' instance is provided for consistency with the framework, and could
  // be used for logging, storing LLM configurations, or user preferences if those
  // were part of this concept's persistent state.
  constructor(private readonly db: Db) {
    // No specific collections are initialized here as the core functionality
    // operates on transient input data.
  }

  /**
   * @action suggestProgression
   * @requires length >= 0, key is a key in standard music notation (e.g., "C", "Am")
   * @effects returns a chord progression of `length` chords in `key`, generated by an LLM.
   */
  async suggestProgression({
    length,
    key,
  }: {
    length: number;
    key: string;
  }): Promise<{ progression: string[] } | { error: string }> {
    // Validate inputs
    if (length < 0) {
      return { error: "Length must be non-negative." };
    }
    if (!this.isValidKey(key)) {
      return { error: `Invalid key: "${key}". Please use standard music notation (e.g., C, G, Am).` };
    }

    // Simulate LLM interaction for generating a progression
    const progression = this.mockLlmLiteProgression(length, key);

    return { progression };
  }

  /**
   * @action suggestChord
   * @requires every `chord` is a valid chord in standard music notation (e.g., "C", "G7") or `null`,
   *           `position` is a valid index in the `chords` array, `key` is a valid key.
   * @effects returns a list of suggested chords to put in `position`, generated by an LLM
   *          given the context of the chords before and after it and the specified `key`.
   *
   * @note The `key` parameter is crucial for musical suggestions and is assumed to be part
   *       of the context passed to the action, even if not explicitly listed in the original
   *       concept spec's action signature. For a production concept design, it would be explicitly added.
   */
  async suggestChord({
    chords,
    position,
    key,
  }: {
    chords: (string | null)[];
    position: number;
    key: string;
  }): Promise<{ suggestions: string[] } | { error: string }> {
    // Validate inputs
    if (!Array.isArray(chords)) {
      return { error: "Chords must be an array." };
    }
    if (position < 0 || position >= chords.length) {
      return { error: "Position is out of bounds for the given chords array." };
    }
    for (const chord of chords) {
      if (chord !== null && !this.isValidChord(chord)) {
        return { error: `Invalid chord "${chord}" found in the progression.` };
      }
    }
    if (!this.isValidKey(key)) {
      return { error: `Invalid key: "${key}". Please use standard music notation (e.g., C, G, Am).` };
    }

    // Simulate LLM interaction based on context
    const suggestions = this.mockLlmLiteChordSuggestions(chords, position, key);

    return { suggestions };
  }

  // --- Internal Helper Methods for Mocking LLM and Validation ---

  /**
   * Checks if a given string represents a valid musical key.
   * This is a simplified check for demonstration purposes.
   */
  private isValidKey(key: string): boolean {
    const validKeys = [
      "C", "G", "D", "A", "E", "B", "F#", "Db", "Ab", "Eb", "Bb", "F",
      "Am", "Em", "Bm", "F#m", "C#m", "G#m", "D#m", "Bbm", "Fm", "Cm", "Gm", "Dm"
    ];
    return validKeys.includes(key);
  }

  /**
   * Checks if a given string represents a valid musical chord.
   * This is a basic regex check; real-world validation would be more comprehensive.
   * Supports common chord types like C, Cm, G7, Fsus4.
   */
  private isValidChord(chord: string): boolean {
    const regex = /^[A-G](b|#)?(maj|min|dim|aug|sus|dom)?[0-9]*$/i;
    return regex.test(chord);
  }

  /**
   * Mocks the behavior of an LLM generating a full chord progression.
   * Provides a very simple, deterministic progression for common keys.
   */
  private mockLlmLiteProgression(length: number, key: string): string[] {
    const majorScaleChords: Record<string, string[]> = {
      "C": ["C", "Dm", "Em", "F", "G", "Am"], // Simplified to remove dim for mock
      "G": ["G", "Am", "Bm", "C", "D", "Em"],
      "D": ["D", "Em", "F#m", "G", "A", "Bm"],
      "F": ["F", "Gm", "Am", "Bb", "C", "Dm"],
    };
    const minorScaleChords: Record<string, string[]> = {
      "Am": ["Am", "Bdim", "C", "Dm", "Em", "F", "G"], // Bdim included for Am
      "Em": ["Em", "F#dim", "G", "Am", "Bm", "C", "D"],
    };

    const isMinor = key.endsWith("m");
    const chordsInKey = isMinor ? minorScaleChords[key] : majorScaleChords[key];

    if (!chordsInKey) {
      // Fallback for unsupported mock keys
      return Array(length).fill("C");
    }

    const progression: string[] = [];
    for (let i = 0; i < length; i++) {
      let nextChord = chordsInKey[0]; // Default to tonic

      if (i > 0) {
        const lastChord = progression[i - 1];
        switch (lastChord) {
          case chordsInKey[0]: // Tonic (I)
            nextChord = chordsInKey[4] || chordsInKey[3]; // Move to Dominant (V) or Subdominant (IV)
            break;
          case chordsInKey[4]: // Dominant (V)
            nextChord = chordsInKey[0]; // Resolve to Tonic (I)
            break;
          case chordsInKey[3]: // Subdominant (IV)
            nextChord = chordsInKey[4] || chordsInKey[0]; // Move to Dominant (V) or Tonic (I)
            break;
          default:
            // For other chords, pick a random common next chord or revert to tonic
            nextChord = chordsInKey[Math.floor(Math.random() * chordsInKey.length)];
            if (Math.random() > 0.7) nextChord = chordsInKey[0]; // Tendency to resolve
            break;
        }
      }
      progression.push(nextChord);
    }
    return progression;
  }

  /**
   * Mocks the behavior of an LLM suggesting chords for a specific slot.
   * Provides simple, context-aware suggestions based on common Western music theory.
   */
  private mockLlmLiteChordSuggestions(
    chords: (string | null)[],
    position: number,
    key: string,
  ): string[] {
    const before = chords[position - 1];
    const after = chords[position + 1]; // Can be undefined

    // Example common chords in C major for simple context
    const commonSuggestions: Record<string, string[]> = {
      "C": ["C", "G", "Am", "F", "Dm", "Em"],
      "G": ["G", "C", "D", "Em", "Am", "Bm"],
      "Am": ["Am", "G", "C", "F", "Dm", "Em"],
      "F": ["F", "C", "G", "Dm", "Am", "Bb"], // Bb if modulating or bluesy
    };

    const keySuggestions = commonSuggestions[key] || ["C", "G", "Am", "F"]; // Fallback if key not in mock

    // Case 1: Sequence is empty or only has one slot
    if (chords.length === 1 && chords[0] === null) {
      return [key, (key.endsWith("m") ? "" : key + "m"), ...keySuggestions.filter(c => c !== key && c !== (key + "m"))]; // Suggest tonic, relative minor/major
    }
    if (chords.length === 0) { // Should be caught by length check in action, but defensive
      return [key, ...keySuggestions.filter(c => c !== key)];
    }

    // Case 2: At the beginning of the sequence (position 0)
    if (position === 0) {
      if (after === "C") return ["G", "F", "Am"];
      if (after === "G") return ["C", "D", "Em"];
      // General suggestions for start
      return [key, (key.endsWith("m") ? "" : key + "m"), ...keySuggestions].filter(c => c !== after);
    }

    // Case 3: At the end of the sequence
    if (position === chords.length - 1) {
      if (before === "G") return ["C", "Cmaj7"]; // G usually resolves to C
      if (before === "F") return ["C", "G", "Am"];
      if (before === "Am") return ["G", "Dm", "F"];
      return [...keySuggestions].filter(c => c !== before);
    }

    // Case 4: Middle of the sequence (both before and after context)
    if (before && after) {
      if (before === "C" && after === "G") return ["F", "Dm", "Cmaj7"];
      if (before === "Am" && after === "G") return ["F", "Dm"];
      if (before === "F" && after === "C") return ["G", "C7"];
      if (before === "G" && after === "C") return ["C", "Am"]; // A common resolution
      // Fallback, filter out existing chords
      return [...keySuggestions].filter(c => c !== before && c !== after);
    } else if (before) { // Only 'before' context, this would be for position > 0 and not the end
        if (before === "C") return ["F", "G", "Dm"];
        if (before === "G") return ["C", "Am"];
        return [...keySuggestions].filter(c => c !== before);
    }


    // Default fallback if no specific rule matches (e.g., all nulls around)
    return keySuggestions;
  }
}
```